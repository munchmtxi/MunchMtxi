// src/config/socket.js
const socketIO = require('socket.io');
const jwt = require('jsonwebtoken');
const config = require('./config');
const logger = require('../utils/logger');
const { Order, User, Driver, Merchant } = require('../models');

// Socket event constants
const SOCKET_EVENTS = {
  // Order Events
  ORDER_CREATED: 'order:created',
  ORDER_UPDATED: 'order:updated',
  ORDER_CANCELLED: 'order:cancelled',
  ORDER_ASSIGNED: 'order:assigned',
  
  // Driver Events
  DRIVER_LOCATION_UPDATED: 'driver:locationUpdated',
  DRIVER_STATUS_CHANGED: 'driver:statusChanged',
  DRIVER_ASSIGNED: 'driver:assigned',
  
  // Table Booking Events
  TABLE_BOOKED: 'table:booked',
  TABLE_STATUS_CHANGED: 'table:statusChanged',
  TABLE_CANCELLED: 'table:cancelled',
  
  // Quick Link Events
  ASSISTANCE_REQUESTED: 'quickLink:assistanceRequested',
  BILL_REQUESTED: 'quickLink:billRequested',
  EMERGENCY_HELP: 'quickLink:emergencyHelp',
  
  // Connection Events
  CONNECT: 'connect',
  DISCONNECT: 'disconnect',
  ERROR: 'error'
};

const setupSocket = (server) => {
  const io = socketIO(server, {
    cors: {
      origin: config.frontendUrl,
      methods: ['GET', 'POST'],
      credentials: true
    },
  });

  // Middleware for authentication
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      if (!token) {
        return next(new Error('Authentication token required'));
      }

      const decoded = jwt.verify(token, config.jwt.secret);
      const user = await User.findByPk(decoded.id);
      
      if (!user) {
        return next(new Error('User not found'));
      }

      socket.user = user;
      next();
    } catch (error) {
      logger.error('Socket authentication error:', error);
      next(new Error('Authentication failed'));
    }
  });

  // Room management functions
  const joinUserRooms = async (socket) => {
    const { user } = socket;
    
    // Join role-specific room
    socket.join(`role:${user.role}`);
    
    // Join user-specific room
    socket.join(`user:${user.id}`);
    
    // Role-specific room joining
    switch (user.role) {
      case 'merchant':
        const merchant = await Merchant.findOne({ where: { userId: user.id } });
        if (merchant) {
          socket.join(`merchant:${merchant.id}`);
        }
        break;
      
      case 'driver':
        const driver = await Driver.findOne({ where: { userId: user.id } });
        if (driver) {
          socket.join(`driver:${driver.id}`);
        }
        break;
    }
    
    logger.info(`User ${user.id} joined their rooms`);
  };

  const handleOrderEvents = (socket) => {
    // Listen for order status updates
    socket.on(SOCKET_EVENTS.ORDER_UPDATED, async (data) => {
      try {
        const { orderId, status } = data;
        const order = await Order.findByPk(orderId);
        
        if (!order) {
          throw new Error('Order not found');
        }

        // Emit to relevant rooms
        io.to(`user:${order.customerId}`).emit(SOCKET_EVENTS.ORDER_UPDATED, {
          orderId,
          status,
          timestamp: new Date()
        });
        
        io.to(`merchant:${order.merchantId}`).emit(SOCKET_EVENTS.ORDER_UPDATED, {
          orderId,
          status,
          timestamp: new Date()
        });
        
        logger.info(`Order ${orderId} status updated to ${status}`);
      } catch (error) {
        logger.error('Error handling order update:', error);
        socket.emit(SOCKET_EVENTS.ERROR, { message: 'Failed to update order status' });
      }
    });
  };

  const handleDriverEvents = (socket) => {
    // Handle driver location updates
    socket.on(SOCKET_EVENTS.DRIVER_LOCATION_UPDATED, async (data) => {
      try {
        const { location } = data;
        const driver = await Driver.findOne({ where: { userId: socket.user.id } });
        
        if (!driver) {
          throw new Error('Driver not found');
        }

        // Update driver location
        await driver.update({ currentLocation: location });
        
        // Emit to relevant rooms (active orders' customers and merchants)
        const activeOrders = await Order.findAll({
          where: { 
            driverId: driver.id,
            status: ['assigned', 'pickup', 'delivering']
          }
        });
        
        activeOrders.forEach(order => {
          io.to(`user:${order.customerId}`).emit(SOCKET_EVENTS.DRIVER_LOCATION_UPDATED, {
            orderId: order.id,
            location,
            timestamp: new Date()
          });
          
          io.to(`merchant:${order.merchantId}`).emit(SOCKET_EVENTS.DRIVER_LOCATION_UPDATED, {
            orderId: order.id,
            location,
            timestamp: new Date()
          });
        });
        
        logger.info(`Driver ${driver.id} location updated`);
      } catch (error) {
        logger.error('Error handling driver location update:', error);
        socket.emit(SOCKET_EVENTS.ERROR, { message: 'Failed to update location' });
      }
    });
  };

  const handleQuickLinkEvents = (socket) => {
    // Handle assistance requests
    socket.on(SOCKET_EVENTS.ASSISTANCE_REQUESTED, async (data) => {
      try {
        const { tableId, merchantId, requestType } = data;
        
        // Emit to merchant and staff
        io.to(`merchant:${merchantId}`).emit(SOCKET_EVENTS.ASSISTANCE_REQUESTED, {
          tableId,
          requestType,
          userId: socket.user.id,
          timestamp: new Date()
        });
        
        logger.info(`Assistance requested for table ${tableId} at merchant ${merchantId}`);
      } catch (error) {
        logger.error('Error handling assistance request:', error);
        socket.emit(SOCKET_EVENTS.ERROR, { message: 'Failed to request assistance' });
      }
    });

    // Handle emergency help requests
    socket.on(SOCKET_EVENTS.EMERGENCY_HELP, async (data) => {
      try {
        const { merchantId, tableId } = data;
        
        // Emit to merchant, staff, and admins
        io.to(`merchant:${merchantId}`).emit(SOCKET_EVENTS.EMERGENCY_HELP, {
          tableId,
          userId: socket.user.id,
          timestamp: new Date(),
          priority: 'high'
        });
        
        io.to('role:admin').emit(SOCKET_EVENTS.EMERGENCY_HELP, {
          merchantId,
          tableId,
          userId: socket.user.id,
          timestamp: new Date(),
          priority: 'high'
        });
        
        logger.warn(`Emergency help requested for table ${tableId} at merchant ${merchantId}`);
      } catch (error) {
        logger.error('Error handling emergency help request:', error);
        socket.emit(SOCKET_EVENTS.ERROR, { message: 'Failed to request emergency help' });
      }
    });
  };

  // Connection handling
  io.on(SOCKET_EVENTS.CONNECT, async (socket) => {
    try {
      await joinUserRooms(socket);
      
      // Set up event handlers based on user role
      handleOrderEvents(socket);
      
      if (socket.user.role === 'driver') {
        handleDriverEvents(socket);
      }
      
      if (socket.user.role === 'customer') {
        handleQuickLinkEvents(socket);
      }
      
      logger.info(`User connected: ${socket.user.id} (${socket.user.role})`);
      
      // Handle disconnection
      socket.on(SOCKET_EVENTS.DISCONNECT, () => {
        logger.info(`User disconnected: ${socket.user.id}`);
      });
      
    } catch (error) {
      logger.error('Error in socket connection:', error);
      socket.emit(SOCKET_EVENTS.ERROR, { message: 'Connection error' });
      socket.disconnect(true);
    }
  });

  return io;
};

module.exports = { 
  setupSocket,
  SOCKET_EVENTS 
};

// src/config/socket.js
const socketIO = require('socket.io');
const jwt = require('jsonwebtoken');
const config = require('./config');
const logger = require('../utils/logger');

// Event types based on architecture document
const EVENTS = {
  // Customer Events (Section 3.1)
  CUSTOMER: {
    ORDER_STATUS: 'customer:order:status',
    TABLE_BOOKING: 'customer:table:booking',
    TAXI_LOCATION: 'customer:taxi:location',
    QUICK_LINK: 'customer:quicklink'
  },

  // Merchant Events (Section 3.2)
  MERCHANT: {
    NEW_ORDER: 'merchant:order:new',
    INVENTORY_UPDATE: 'merchant:inventory:update',
    BOOKING_REQUEST: 'merchant:booking:request',
    STAFF_TASK: 'merchant:staff:task'
  },

  // Staff Events (Section 3.3)
  STAFF: {
    TASK_ASSIGNED: 'staff:task:assigned',
    EARNINGS_UPDATE: 'staff:earnings:update',
    QUICK_LINK_REQUEST: 'staff:quicklink:request'
  },

  // Driver Events (Section 3.4)
  DRIVER: {
    JOB_ASSIGNED: 'driver:job:assigned',
    LOCATION_UPDATE: 'driver:location:update',
    EARNINGS_UPDATE: 'driver:earnings:update'
  },

  // Admin Events (Section 3.5)
  ADMIN: {
    SYSTEM_ALERT: 'admin:system:alert',
    PERFORMANCE_METRIC: 'admin:performance:metric'
  }
};

const setupSocket = (server) => {
  const io = socketIO(server, {
    cors: {
      origin: config.frontendUrl,
      methods: ['GET', 'POST']
    }
  });

  // Authentication middleware
  io.use((socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      if (!token) {
        return next(new Error('Authentication required'));
      }

      const decoded = jwt.verify(token, config.jwt.secret);
      socket.user = decoded;
      next();
    } catch (error) {
      logger.error('Socket authentication error:', error);
      next(new Error('Authentication failed'));
    }
  });

  io.on('connection', (socket) => {
    const { user } = socket;
    logger.info(`User connected: ${user.id} (${user.role})`);

    // Join role-based room
    socket.join(`role:${user.role}`);
    socket.join(`user:${user.id}`);

    // Customer Event Handlers (Section 3.1)
    if (user.role === 'customer') {
      // Table Booking & In-Dining Features (Section 3.1.3)
      socket.on(EVENTS.CUSTOMER.TABLE_BOOKING, (data) => {
        io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.BOOKING_REQUEST, {
          customerId: user.id,
          ...data
        });
      });

      // Quick Links (Section 3.1.6)
      socket.on(EVENTS.CUSTOMER.QUICK_LINK, (data) => {
        io.to(`merchant:${data.merchantId}`).emit(EVENTS.STAFF.QUICK_LINK_REQUEST, {
          customerId: user.id,
          requestType: data.type,
          tableId: data.tableId
        });
      });
    }

    // Merchant Event Handlers (Section 3.2)
    if (user.role === 'merchant') {
      // Order & Booking Management (Section 3.2.3)
      socket.on(EVENTS.MERCHANT.NEW_ORDER, (data) => {
        io.to(`user:${data.customerId}`).emit(EVENTS.CUSTOMER.ORDER_STATUS, {
          status: 'received',
          orderId: data.orderId
        });
      });

      // Staff Management (Section 3.2.5)
      socket.on(EVENTS.MERCHANT.STAFF_TASK, (data) => {
        io.to(`user:${data.staffId}`).emit(EVENTS.STAFF.TASK_ASSIGNED, {
          taskId: data.taskId,
          details: data.details
        });
      });
    }

    // Staff Event Handlers (Section 3.3)
    if (user.role === 'staff') {
      // Task Management (Section 3.3.2)
      socket.on(EVENTS.STAFF.TASK_ASSIGNED, (data) => {
        io.to(`merchant:${data.merchantId}`).emit('staff:task:update', {
          staffId: user.id,
          taskId: data.taskId,
          status: data.status
        });
      });
    }

    // Driver Event Handlers (Section 3.4)
    if (user.role === 'driver') {
      // Unified Job Management (Section 3.4.2)
      socket.on(EVENTS.DRIVER.LOCATION_UPDATE, (data) => {
        io.to(`user:${data.customerId}`).emit(EVENTS.CUSTOMER.TAXI_LOCATION, {
          driverId: user.id,
          location: data.location
        });
      });
    }

    // Admin Event Handlers (Section 3.5)
    if (user.role === 'admin') {
      // System Monitoring & Performance (Section 3.5.2)
      socket.on(EVENTS.ADMIN.SYSTEM_ALERT, (data) => {
        io.to('role:merchant').emit('system:alert', {
          type: data.type,
          message: data.message
        });
      });
    }

    // Handle disconnection
    socket.on('disconnect', () => {
      logger.info(`User disconnected: ${user.id}`);
    });
  });

  return io;
};

module.exports = {
  setupSocket,
  EVENTS
};

Expanded Role-Specific Events:

Customers: Full order lifecycle, table booking, taxi tracking
Merchants: Inventory alerts, staff management, order processing
Staff: Task management, earnings updates, performance metrics
Drivers: Job management, location updates, earnings tracking
Admins: System monitoring, user management, performance tracking


Enhanced Notification System:

Multi-channel notifications (WebSocket + WhatsApp)
Priority-based notification routing
Role-specific notification templates
Real-time alerts for critical events


Specific Features by Section:

For Customers (3.1):
javascriptCopy// Table Booking (3.1.3)
CUSTOMER.TABLE_BOOKING
CUSTOMER.TABLE_CONFIRMED
CUSTOMER.TABLE_READY

// Quick Links (3.1.6)
CUSTOMER.CALL_WAITER
CUSTOMER.REQUEST_BILL
CUSTOMER.EMERGENCY_HELP
For Merchants (3.2):
javascriptCopy// Inventory Management (3.2.2)
MERCHANT.INVENTORY_LOW
MERCHANT.ITEM_UNAVAILABLE

// Staff Management (3.2.5)
MERCHANT.STAFF_TASK
MERCHANT.STAFF_LOCATION
For Staff (3.3):
javascriptCopy// Task Management (3.3.2)
STAFF.TASK_ASSIGNED
STAFF.TASK_COMPLETED

// Earnings Management (3.3.3)
STAFF.TIP_RECEIVED
STAFF.SALARY_UPDATED
For Drivers (3.4):
javascriptCopy// Job Management (3.4.2)
DRIVER.JOB_ASSIGNED
DRIVER.JOB_ACCEPTED

// Navigation (3.4.4)
DRIVER.LOCATION_UPDATE
DRIVER.ROUTE_OPTIMIZED

// src/services/notificationTemplates.js
const templates = {
    // Customer Templates (3.1.5)
    CUSTOMER: {
      ORDER_CONFIRMED: {
        title: 'Order Confirmation',
        template: (data) => ({
          inApp: `Your order #${data.orderId} has been confirmed`,
          whatsapp: `ðŸ›ï¸ MunchMtxi: Order #${data.orderId} confirmed! Total: ${data.total}. Track your order in the app.`,
          email: {
            subject: 'Order Confirmation - MunchMtxi',
            body: `Your order #${data.orderId} has been confirmed. Total: ${data.total}`
          }
        })
      },
      TABLE_READY: {
        title: 'Table Ready',
        template: (data) => ({
          inApp: `Your table at ${data.merchantName} is ready`,
          whatsapp: `ðŸª‘ MunchMtxi: Your table at ${data.merchantName} is ready! Please proceed to the restaurant.`,
          priority: 'high'
        })
      },
      DRIVER_ASSIGNED: {
        title: 'Driver Assigned',
        template: (data) => ({
          inApp: `${data.driverName} has been assigned to your order`,
          whatsapp: `ðŸš— MunchMtxi: Your driver ${data.driverName} is on the way! Track in real-time on the app.`
        })
      }
    },
  
    // Merchant Templates (3.2)
    MERCHANT: {
      NEW_ORDER: {
        title: 'New Order Received',
        template: (data) => ({
          inApp: `New order #${data.orderId} received`,
          whatsapp: `ðŸ“ New Order #${data.orderId}\nTotal: ${data.total}\nItems: ${data.itemCount}`,
          priority: 'high'
        })
      },
      INVENTORY_ALERT: {
        title: 'Low Inventory Alert',
        template: (data) => ({
          inApp: `Low stock alert: ${data.itemName} (${data.currentStock} remaining)`,
          whatsapp: `âš ï¸ Inventory Alert: ${data.itemName} is running low (${data.currentStock} remaining)`,
          priority: 'medium'
        })
      },
      STAFF_PERFORMANCE: {
        title: 'Staff Performance Update',
        template: (data) => ({
          inApp: `Performance update for ${data.staffName}`,
          email: {
            subject: 'Staff Performance Report',
            body: `Performance metrics for ${data.staffName}:\n${data.metrics}`
          }
        })
      }
    },
  
    // Staff Templates (3.3)
    STAFF: {
      NEW_TASK: {
        title: 'New Task Assigned',
        template: (data) => ({
          inApp: `New task: ${data.taskType} (Table ${data.tableId})`,
          whatsapp: `ðŸ”” New Task: ${data.taskType}\nTable: ${data.tableId}\nPriority: ${data.priority}`,
          priority: data.priority
        })
      },
      TIP_RECEIVED: {
        title: 'New Tip Received',
        template: (data) => ({
          inApp: `You received a tip of ${data.amount}`,
          whatsapp: `ðŸ’° You received a tip of ${data.amount} from order #${data.orderId}`
        })
      }
    },
  
    // Driver Templates (3.4)
    DRIVER: {
      NEW_JOB: {
        title: 'New Delivery Job',
        template: (data) => ({
          inApp: `New delivery request from ${data.pickupLocation}`,
          whatsapp: `ðŸ“¦ New Delivery\nPickup: ${data.pickupLocation}\nDrop: ${data.dropLocation}\nEarnings: ${data.earnings}`,
          priority: 'high'
        })
      },
      ROUTE_UPDATE: {
        title: 'Route Optimization',
        template: (data) => ({
          inApp: `Route updated: New ETA ${data.newEta}`,
          whatsapp: `ðŸ—ºï¸ Route Updated\nNew ETA: ${data.newEta}\nReason: ${data.reason}`
        })
      }
    }
  };
  
  // src/services/notificationService.js
  const NotificationService = {
    async send(userId, type, subtype, data) {
      try {
        const template = templates[type][subtype];
        if (!template) throw new Error('Template not found');
  
        const notification = template.template(data);
        
        // Send in-app notification via socket
        io.to(`user:${userId}`).emit('notification', {
          title: template.title,
          message: notification.inApp,
          priority: notification.priority || 'normal',
          timestamp: new Date(),
          data
        });
  
        // Send WhatsApp notification if message exists
        if (notification.whatsapp) {
          await sendWhatsAppMessage(data.phoneNumber, notification.whatsapp);
        }
  
        // Send email if template exists
        if (notification.email) {
          await sendEmail({
            to: data.email,
            subject: notification.email.subject,
            text: notification.email.body
          });
        }
  
        return true;
      } catch (error) {
        logger.error('Notification error:', error);
        return false;
      }
    }
  };
  
  // src/config/socket.js additions
  const customerHandlers = {
    // Enhanced Order Management (3.1.2)
    handleOrderUpdates: (socket) => {
      socket.on(EVENTS.CUSTOMER.ORDER_STATUS_REQUEST, async (data) => {
        try {
          const order = await Order.findByPk(data.orderId);
          io.to(`user:${socket.user.id}`).emit(EVENTS.CUSTOMER.ORDER_STATUS_UPDATE, {
            orderId: order.id,
            status: order.status,
            eta: order.estimatedDeliveryTime
          });
        } catch (error) {
          socket.emit('error', { message: 'Failed to fetch order status' });
        }
      });
    },
  
    // Enhanced Table Service (3.1.3)
    handleTableService: (socket) => {
      socket.on(EVENTS.CUSTOMER.TABLE_SERVICE_REQUEST, async (data) => {
        try {
          // Create service request
          const request = await TableService.create({
            customerId: socket.user.id,
            merchantId: data.merchantId,
            tableId: data.tableId,
            requestType: data.requestType
          });
  
          // Notify merchant and staff
          io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.TABLE_SERVICE_NEEDED, {
            requestId: request.id,
            tableId: data.tableId,
            requestType: data.requestType
          });
  
          await NotificationService.send(socket.user.id, 'CUSTOMER', 'SERVICE_REQUEST_CONFIRMED', {
            requestType: data.requestType,
            tableId: data.tableId
          });
        } catch (error) {
          socket.emit('error', { message: 'Failed to request table service' });
        }
      });
    }
  };
  
  const merchantHandlers = {
    // Enhanced Inventory Management (3.2.2)
    handleInventoryUpdates: (socket) => {
      socket.on(EVENTS.MERCHANT.INVENTORY_UPDATE, async (data) => {
        try {
          // Update inventory
          await Inventory.update(data.updates);
  
          // Check for low stock
          const lowStockItems = data.updates.filter(item => item.quantity <= item.threshold);
          if (lowStockItems.length > 0) {
            await NotificationService.send(socket.user.id, 'MERCHANT', 'INVENTORY_ALERT', {
              items: lowStockItems
            });
          }
        } catch (error) {
          socket.emit('error', { message: 'Failed to update inventory' });
        }
      });
    },
  
    // Enhanced Staff Management (3.2.5)
    handleStaffTasks: (socket) => {
      socket.on(EVENTS.MERCHANT.ASSIGN_STAFF_TASK, async (data) => {
        try {
          // Create and assign task
          const task = await StaffTask.create({
            staffId: data.staffId,
            type: data.type,
            priority: data.priority,
            details: data.details
          });
  
          // Notify staff
          await NotificationService.send(data.staffId, 'STAFF', 'NEW_TASK', {
            taskId: task.id,
            taskType: data.type,
            priority: data.priority,
            ...data.details
          });
        } catch (error) {
          socket.emit('error', { message: 'Failed to assign staff task' });
        }
      });
    }
  };
  

  // src/services/notificationService.js

const AppError = require('../utils/AppError');
const logger = require('../utils/logger');

// Notification Channels
const CHANNELS = {
  IN_APP: 'in_app',
  WHATSAPP: 'whatsapp',
  EMAIL: 'email',
  SMS: 'sms',
  PUSH: 'push'
};

// Notification Priority Levels
const PRIORITY = {
  LOW: 'low',
  NORMAL: 'normal',
  HIGH: 'high',
  URGENT: 'urgent'
};

class NotificationError extends AppError {
  constructor(message, details) {
    super(message, 500, 'NOTIFICATION_ERROR', details);
  }
}

const NotificationService = {
  async send(userId, type, subtype, data, channels = [CHANNELS.IN_APP]) {
    try {
      const template = templates[type][subtype];
      if (!template) {
        throw new NotificationError('Template not found', { type, subtype });
      }

      const results = [];
      const errors = [];

      // Process each requested channel
      for (const channel of channels) {
        try {
          switch (channel) {
            case CHANNELS.IN_APP:
              await this.sendInApp(userId, template, data);
              break;
            case CHANNELS.WHATSAPP:
              await this.sendWhatsApp(userId, template, data);
              break;
            case CHANNELS.EMAIL:
              await this.sendEmail(userId, template, data);
              break;
            case CHANNELS.SMS:
              await this.sendSMS(userId, template, data);
              break;
            case CHANNELS.PUSH:
              await this.sendPushNotification(userId, template, data);
              break;
            default:
              throw new NotificationError('Invalid channel', { channel });
          }
          results.push({ channel, success: true });
        } catch (error) {
          errors.push({ channel, error: error.message });
          logger.error(`Notification error for channel ${channel}:`, error);
        }
      }

      // Log notification attempt
      await NotificationLog.create({
        userId,
        type,
        subtype,
        channels,
        success: errors.length === 0,
        errors: errors.length > 0 ? errors : null,
        data
      });

      // Throw error if all channels failed
      if (errors.length === channels.length) {
        throw new NotificationError('All notification channels failed', { errors });
      }

      return {
        success: errors.length === 0,
        results,
        errors: errors.length > 0 ? errors : null
      };
    } catch (error) {
      logger.error('Notification service error:', error);
      throw error;
    }
  }
};

// src/config/socket.js - Staff Handlers
const staffHandlers = {
  // Task Management (3.3.2)
  handleTaskManagement: (socket) => {
    // Accept task
    socket.on(EVENTS.STAFF.TASK_ACCEPT, async (data) => {
      try {
        const task = await StaffTask.update({
          id: data.taskId,
          status: 'accepted',
          acceptedAt: new Date()
        });

        // Notify merchant
        await NotificationService.send(task.merchantId, 'MERCHANT', 'TASK_ACCEPTED', {
          taskId: task.id,
          staffId: socket.user.id,
          estimatedCompletionTime: data.estimatedCompletionTime
        }, [CHANNELS.IN_APP, CHANNELS.WHATSAPP]);

      } catch (error) {
        handleSocketError(socket, 'Failed to accept task', error);
      }
    });

    // Update task progress
    socket.on(EVENTS.STAFF.TASK_PROGRESS, async (data) => {
      try {
        await StaffTask.update({
          id: data.taskId,
          progress: data.progress,
          currentStep: data.step
        });

        // Notify relevant parties
        io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.TASK_PROGRESS_UPDATE, {
          taskId: data.taskId,
          progress: data.progress,
          step: data.step
        });
      } catch (error) {
        handleSocketError(socket, 'Failed to update task progress', error);
      }
    });

    // Complete task
    socket.on(EVENTS.STAFF.TASK_COMPLETE, async (data) => {
      try {
        const task = await StaffTask.complete(data.taskId);

        // Update staff metrics
        await StaffMetrics.updateTaskCompletion(socket.user.id, task);

        // Notify merchant
        await NotificationService.send(task.merchantId, 'MERCHANT', 'TASK_COMPLETED', {
          taskId: task.id,
          staffId: socket.user.id,
          completionTime: new Date(),
          metrics: await StaffMetrics.getLatestMetrics(socket.user.id)
        }, [CHANNELS.IN_APP, CHANNELS.WHATSAPP]);

      } catch (error) {
        handleSocketError(socket, 'Failed to complete task', error);
      }
    });
  },

  // Earnings Management (3.3.3)
  handleEarningsUpdates: (socket) => {
    socket.on(EVENTS.STAFF.TIP_RECEIVED, async (data) => {
      try {
        await StaffEarnings.recordTip({
          staffId: socket.user.id,
          amount: data.amount,
          orderId: data.orderId
        });

        await NotificationService.send(socket.user.id, 'STAFF', 'TIP_RECEIVED', {
          amount: data.amount,
          orderId: data.orderId
        }, [CHANNELS.IN_APP, CHANNELS.WHATSAPP]);

      } catch (error) {
        handleSocketError(socket, 'Failed to process tip', error);
      }
    });
  },

  // Analytics & Reporting (3.3.4)
  handleMetricsUpdates: (socket) => {
    socket.on(EVENTS.STAFF.REQUEST_METRICS, async (data) => {
      try {
        const metrics = await StaffMetrics.generate(socket.user.id, data.timeframe);
        socket.emit(EVENTS.STAFF.METRICS_UPDATE, metrics);
      } catch (error) {
        handleSocketError(socket, 'Failed to fetch metrics', error);
      }
    });
  }
};

// Driver Handlers (3.4)
const driverHandlers = {
  // Unified Job Management (3.4.2)
  handleJobManagement: (socket) => {
    // Accept job
    socket.on(EVENTS.DRIVER.JOB_ACCEPT, async (data) => {
      try {
        const job = await DriverJob.accept({
          jobId: data.jobId,
          driverId: socket.user.id
        });

        // Update driver status
        await Driver.updateStatus(socket.user.id, 'on_job');

        // Notify customer
        await NotificationService.send(job.customerId, 'CUSTOMER', 'DRIVER_ASSIGNED', {
          jobId: job.id,
          driverName: socket.user.name,
          vehicleDetails: await Driver.getVehicleDetails(socket.user.id),
          estimatedArrival: data.estimatedArrival
        }, [CHANNELS.IN_APP, CHANNELS.WHATSAPP, CHANNELS.PUSH]);

      } catch (error) {
        handleSocketError(socket, 'Failed to accept job', error);
      }
    });

    // Update job status
    socket.on(EVENTS.DRIVER.JOB_STATUS_UPDATE, async (data) => {
      try {
        const job = await DriverJob.updateStatus({
          jobId: data.jobId,
          status: data.status,
          location: data.location
        });

        // Notify customer of status change
        await NotificationService.send(job.customerId, 'CUSTOMER', 'DRIVER_STATUS_UPDATE', {
          jobId: job.id,
          status: data.status,
          location: data.location,
          estimatedArrival: data.estimatedArrival
        }, [CHANNELS.IN_APP, CHANNELS.PUSH]);

      } catch (error) {
        handleSocketError(socket, 'Failed to update job status', error);
      }
    });
  },

  // Navigation & Route Optimization (3.4.4)
  handleNavigation: (socket) => {
    // Regular location updates
    socket.on(EVENTS.DRIVER.LOCATION_UPDATE, async (data) => {
      try {
        await DriverLocation.update(socket.user.id, data.location);
        
        // Get active job if exists
        const activeJob = await DriverJob.getActive(socket.user.id);
        if (activeJob) {
          // Check if route optimization is needed
          const optimizedRoute = await RouteOptimizer.check(
            data.location,
            activeJob.destination,
            activeJob.routePlan
          );

          if (optimizedRoute.shouldUpdate) {
            await NotificationService.send(socket.user.id, 'DRIVER', 'ROUTE_OPTIMIZED', {
              jobId: activeJob.id,
              newRoute: optimizedRoute.route,
              reason: optimizedRoute.reason
            }, [CHANNELS.IN_APP]);
          }

          // Update customer about driver location
          await NotificationService.send(activeJob.customerId, 'CUSTOMER', 'DRIVER_LOCATION', {
            jobId: activeJob.id,
            location: data.location,
            estimatedArrival: optimizedRoute.estimatedArrival
          }, [CHANNELS.IN_APP]);
        }

      } catch (error) {
        handleSocketError(socket, 'Failed to update location', error);
      }
    });
  },

  // Earnings & Tip Management (3.4.3)
  handleEarnings: (socket) => {
    socket.on(EVENTS.DRIVER.EARNINGS_UPDATE, async (data) => {
      try {
        const earnings = await DriverEarnings.record({
          driverId: socket.user.id,
          jobId: data.jobId,
          amount: data.amount,
          type: data.type // 'fare' or 'tip'
        });

        await NotificationService.send(socket.user.id, 'DRIVER', 'EARNINGS_UPDATE', {
          amount: data.amount,
          type: data.type,
          totalToday: earnings.totalToday
        }, [CHANNELS.IN_APP, CHANNELS.WHATSAPP]);

      } catch (error) {
        handleSocketError(socket, 'Failed to update earnings', error);
      }
    });
  }
};

// Error handling utility
const handleSocketError = (socket, message, error) => {
  logger.error(message, error);
  socket.emit('error', {
    message,
    details: error.details || null,
    code: error.errorCode || 'SOCKET_ERROR'
  });
};

module.exports = {
  NotificationService,
  staffHandlers,
  driverHandlers,
  CHANNELS,
  PRIORITY
};

// src/handlers/customerHandlers.js
const customerHandlers = {
    // 3.1.1 Authentication & Account Management
    handleAuth: (socket) => {
      socket.on(EVENTS.CUSTOMER.PROFILE_UPDATE, async (data) => {
        try {
          await Customer.update(socket.user.id, data);
          socket.emit(EVENTS.CUSTOMER.PROFILE_UPDATED, { success: true });
        } catch (error) {
          handleSocketError(socket, 'Profile update failed', error);
        }
      });
    },
  
    // 3.1.2 Order Management
    handleOrders: (socket) => {
      // Place new order
      socket.on(EVENTS.CUSTOMER.PLACE_ORDER, async (data) => {
        try {
          const order = await Order.create({
            customerId: socket.user.id,
            merchantId: data.merchantId,
            items: data.items,
            totalAmount: data.total
          });
  
          io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.NEW_ORDER, {
            orderId: order.id,
            items: data.items
          });
        } catch (error) {
          handleSocketError(socket, 'Order placement failed', error);
        }
      });
  
      // Track order
      socket.on(EVENTS.CUSTOMER.TRACK_ORDER, async (data) => {
        try {
          const orderStatus = await Order.getStatus(data.orderId);
          socket.emit(EVENTS.CUSTOMER.ORDER_STATUS_UPDATE, orderStatus);
        } catch (error) {
          handleSocketError(socket, 'Order tracking failed', error);
        }
      });
    },
  
    // 3.1.3 Table Booking & In-Dining Features
    handleTableService: (socket) => {
      // Book table
      socket.on(EVENTS.CUSTOMER.BOOK_TABLE, async (data) => {
        try {
          const booking = await TableBooking.create({
            customerId: socket.user.id,
            merchantId: data.merchantId,
            date: data.date,
            time: data.time,
            guests: data.guests
          });
  
          io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.NEW_BOOKING, booking);
        } catch (error) {
          handleSocketError(socket, 'Table booking failed', error);
        }
      });
  
      // In-dining order
      socket.on(EVENTS.CUSTOMER.IN_DINING_ORDER, async (data) => {
        try {
          const order = await InDiningOrder.create({
            bookingId: data.bookingId,
            items: data.items
          });
  
          io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.NEW_IN_DINING_ORDER, order);
        } catch (error) {
          handleSocketError(socket, 'In-dining order failed', error);
        }
      });
    }
  };
  
  // src/handlers/merchantHandlers.js
  const merchantHandlers = {
    // 3.2.2 Menu & Inventory Management
    handleInventory: (socket) => {
      // Update menu item
      socket.on(EVENTS.MERCHANT.UPDATE_MENU_ITEM, async (data) => {
        try {
          await MenuItem.update(data.itemId, data.updates);
          socket.emit(EVENTS.MERCHANT.MENU_ITEM_UPDATED, { success: true });
        } catch (error) {
          handleSocketError(socket, 'Menu update failed', error);
        }
      });
  
      // Stock update
      socket.on(EVENTS.MERCHANT.UPDATE_STOCK, async (data) => {
        try {
          await Inventory.update(data.itemId, data.quantity);
          if (data.quantity <= data.threshold) {
            socket.emit(EVENTS.MERCHANT.LOW_STOCK_ALERT, {
              itemId: data.itemId,
              quantity: data.quantity
            });
          }
        } catch (error) {
          handleSocketError(socket, 'Stock update failed', error);
        }
      });
    },
  
    // 3.2.3 Order & Booking Management
    handleOrderManagement: (socket) => {
      // Update order status
      socket.on(EVENTS.MERCHANT.UPDATE_ORDER_STATUS, async (data) => {
        try {
          const order = await Order.updateStatus(data.orderId, data.status);
          io.to(`user:${order.customerId}`).emit(EVENTS.CUSTOMER.ORDER_STATUS_UPDATE, {
            orderId: order.id,
            status: data.status
          });
        } catch (error) {
          handleSocketError(socket, 'Order status update failed', error);
        }
      });
  
      // Handle booking response
      socket.on(EVENTS.MERCHANT.RESPOND_TO_BOOKING, async (data) => {
        try {
          const booking = await TableBooking.updateStatus(data.bookingId, data.status);
          io.to(`user:${booking.customerId}`).emit(EVENTS.CUSTOMER.BOOKING_STATUS_UPDATE, {
            bookingId: booking.id,
            status: data.status
          });
        } catch (error) {
          handleSocketError(socket, 'Booking response failed', error);
        }
      });
    }
  };
  
  // src/handlers/staffHandlers.js
  const staffHandlers = {
    // 3.3.2 Task Management
    handleTasks: (socket) => {
      // Update task status
      socket.on(EVENTS.STAFF.UPDATE_TASK_STATUS, async (data) => {
        try {
          const task = await Task.updateStatus(data.taskId, data.status);
          io.to(`merchant:${task.merchantId}`).emit(EVENTS.MERCHANT.TASK_STATUS_UPDATE, {
            taskId: task.id,
            status: data.status
          });
        } catch (error) {
          handleSocketError(socket, 'Task update failed', error);
        }
      });
  
      // Complete task
      socket.on(EVENTS.STAFF.COMPLETE_TASK, async (data) => {
        try {
          const task = await Task.complete(data.taskId);
          io.to(`merchant:${task.merchantId}`).emit(EVENTS.MERCHANT.TASK_COMPLETED, {
            taskId: task.id,
            completionTime: new Date()
          });
        } catch (error) {
          handleSocketError(socket, 'Task completion failed', error);
        }
      });
    },
  
    // 3.3.3 Earnings & Tip Management
    handleEarnings: (socket) => {
      socket.on(EVENTS.STAFF.RECORD_TIP, async (data) => {
        try {
          await StaffEarnings.recordTip({
            staffId: socket.user.id,
            amount: data.amount,
            orderId: data.orderId
          });
        } catch (error) {
          handleSocketError(socket, 'Tip recording failed', error);
        }
      });
    }
  };
  
  // src/handlers/driverHandlers.js
  const driverHandlers = {
    // 3.4.2 Unified Job Management
    handleJobs: (socket) => {
      // Accept delivery
      socket.on(EVENTS.DRIVER.ACCEPT_DELIVERY, async (data) => {
        try {
          const delivery = await Delivery.accept(data.deliveryId, socket.user.id);
          io.to(`merchant:${delivery.merchantId}`).emit(EVENTS.MERCHANT.DRIVER_ASSIGNED, {
            deliveryId: delivery.id,
            driverId: socket.user.id
          });
        } catch (error) {
          handleSocketError(socket, 'Delivery acceptance failed', error);
        }
      });
  
      // Update delivery status
      socket.on(EVENTS.DRIVER.UPDATE_DELIVERY_STATUS, async (data) => {
        try {
          const delivery = await Delivery.updateStatus(data.deliveryId, data.status);
          io.to(`user:${delivery.customerId}`).emit(EVENTS.CUSTOMER.DELIVERY_STATUS_UPDATE, {
            deliveryId: delivery.id,
            status: data.status
          });
        } catch (error) {
          handleSocketError(socket, 'Delivery status update failed', error);
        }
      });
    },
  
    // 3.4.4 Navigation & Route Optimization
    handleNavigation: (socket) => {
      socket.on(EVENTS.DRIVER.UPDATE_LOCATION, async (data) => {
        try {
          await DriverLocation.update(socket.user.id, data.location);
          const activeDelivery = await Delivery.getActive(socket.user.id);
          if (activeDelivery) {
            io.to(`user:${activeDelivery.customerId}`).emit(EVENTS.CUSTOMER.DRIVER_LOCATION_UPDATE, {
              deliveryId: activeDelivery.id,
              location: data.location
            });
          }
        } catch (error) {
          handleSocketError(socket, 'Location update failed', error);
        }
      });
    }
  };
  
  // src/handlers/adminHandlers.js
  const adminHandlers = {
    // 3.5.1 User Management
    handleUserManagement: (socket) => {
      socket.on(EVENTS.ADMIN.UPDATE_USER_STATUS, async (data) => {
        try {
          await User.updateStatus(data.userId, data.status);
          io.to(`user:${data.userId}`).emit(EVENTS.USER.STATUS_CHANGED, {
            status: data.status
          });
        } catch (error) {
          handleSocketError(socket, 'User status update failed', error);
        }
      });
    },
  
    // 3.5.2 System Monitoring & Performance
    handleSystemMonitoring: (socket) => {
      socket.on(EVENTS.ADMIN.SYSTEM_ALERT, async (data) => {
        try {
          await SystemAlert.create(data);
          io.emit(EVENTS.SYSTEM.ALERT, {
            type: data.type,
            message: data.message,
            severity: data.severity
          });
        } catch (error) {
          handleSocketError(socket, 'System alert creation failed', error);
        }
      });
    }
  };
  
  module.exports = {
    customerHandlers,
    merchantHandlers,
    staffHandlers,
    driverHandlers,
    adminHandlers
  };

  // src/handlers/customerHandlers.js
const customerHandlers = {
    // 3.1.2 Order Management - Enhanced
    handleOrders: (socket) => {
      // Place Order with Customizations
      socket.on(EVENTS.CUSTOMER.PLACE_ORDER, async (data) => {
        try {
          // Handle dietary preferences and allergies
          const order = await Order.create({
            customerId: socket.user.id,
            merchantId: data.merchantId,
            items: data.items,
            customizations: data.customizations,
            dietaryPreferences: data.dietaryPreferences,
            allergies: data.allergies,
            specialInstructions: data.specialInstructions,
            deliveryPreferences: data.deliveryPreferences
          });
  
          // Notify merchant with detailed order info
          io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.NEW_ORDER, {
            orderId: order.id,
            details: order
          });
        } catch (error) {
          handleSocketError(socket, 'Order placement failed', error);
        }
      });
  
      // Real-time Order Modifications
      socket.on(EVENTS.CUSTOMER.MODIFY_ORDER, async (data) => {
        try {
          const updatedOrder = await Order.modify(data.orderId, data.modifications);
          
          // Notify merchant of changes
          io.to(`merchant:${updatedOrder.merchantId}`).emit(EVENTS.MERCHANT.ORDER_MODIFIED, {
            orderId: updatedOrder.id,
            modifications: data.modifications
          });
        } catch (error) {
          handleSocketError(socket, 'Order modification failed', error);
        }
      });
    },
  
    // 3.1.3 Table Booking & In-Dining - Enhanced
    handleTableService: (socket) => {
      // Enhanced Table Booking
      socket.on(EVENTS.CUSTOMER.BOOK_TABLE, async (data) => {
        try {
          const booking = await TableBooking.create({
            customerId: socket.user.id,
            merchantId: data.merchantId,
            date: data.date,
            time: data.time,
            guests: data.guests,
            seatingPreferences: data.seatingPreferences,
            occasion: data.occasion,
            specialRequests: data.specialRequests
          });
  
          // Handle group bookings
          if (data.isGroupBooking) {
            await GroupBooking.create({
              bookingId: booking.id,
              groupSize: data.groupSize,
              menuPreOrders: data.menuPreOrders
            });
          }
        } catch (error) {
          handleSocketError(socket, 'Table booking failed', error);
        }
      });
  
      // Quick Links (3.1.6) - Enhanced
      socket.on(EVENTS.CUSTOMER.QUICK_LINK_ACTION, async (data) => {
        try {
          const action = await QuickLink.processAction({
            type: data.type, // CALL_WAITER, REQUEST_BILL, ORDER_MORE, EMERGENCY
            tableId: data.tableId,
            customerId: socket.user.id,
            merchantId: data.merchantId,
            details: data.details
          });
  
          // Priority-based staff notification
          io.to(`merchant:${data.merchantId}`).emit(EVENTS.MERCHANT.QUICK_LINK_REQUEST, {
            actionId: action.id,
            priority: action.priority,
            tableId: data.tableId,
            type: data.type
          });
        } catch (error) {
          handleSocketError(socket, 'Quick link action failed', error);
        }
      });
    },
  
    // 3.1.4 Taxi Booking - Enhanced
    handleTaxiService: (socket) => {
      socket.on(EVENTS.CUSTOMER.REQUEST_TAXI, async (data) => {
        try {
          const request = await TaxiRequest.create({
            customerId: socket.user.id,
            pickup: data.pickup,
            dropoff: data.dropoff,
            scheduledTime: data.scheduledTime,
            vehiclePreferences: data.vehiclePreferences,
            passengerCount: data.passengerCount,
            specialRequirements: data.specialRequirements
          });
  
          // Find nearby drivers
          const availableDrivers = await Driver.findNearby(data.pickup);
          availableDrivers.forEach(driver => {
            io.to(`driver:${driver.id}`).emit(EVENTS.DRIVER.NEW_RIDE_REQUEST, {
              requestId: request.id,
              pickup: data.pickup,
              estimatedFare: request.estimatedFare
            });
          });
        } catch (error) {
          handleSocketError(socket, 'Taxi request failed', error);
        }
      });
    }
  };
  
  // src/handlers/merchantHandlers.js
  const merchantHandlers = {
    // 3.2.2 Menu & Inventory Management - Enhanced
    handleInventory: (socket) => {
      // Real-time inventory tracking
      socket.on(EVENTS.MERCHANT.UPDATE_INVENTORY, async (data) => {
        try {
          const updates = await Inventory.bulkUpdate(data.updates);
          
          // Check stock levels and send alerts
          const lowStockItems = updates.filter(item => item.quantity <= item.threshold);
          if (lowStockItems.length > 0) {
            await NotificationService.send(socket.user.id, 'MERCHANT', 'LOW_STOCK_ALERT', {
              items: lowStockItems,
              urgency: calculateUrgency(lowStockItems)
            });
          }
  
          // Update menu availability in real-time
          await MenuItem.updateAvailability(updates);
        } catch (error) {
          handleSocketError(socket, 'Inventory update failed', error);
        }
      });
  
      // Menu customization and specials
      socket.on(EVENTS.MERCHANT.UPDATE_MENU_SPECIALS, async (data) => {
        try {
          await MenuItem.updateSpecials({
            items: data.items,
            startTime: data.startTime,
            endTime: data.endTime,
            discountType: data.discountType,
            discountValue: data.discountValue
          });
  
          // Notify customers who have opted in for specials
          const interestedCustomers = await Customer.findInterestedInSpecials(socket.user.id);
          interestedCustomers.forEach(customer => {
            io.to(`user:${customer.id}`).emit(EVENTS.CUSTOMER.NEW_SPECIALS_AVAILABLE, {
              merchantId: socket.user.id,
              specials: data.items
            });
          });
        } catch (error) {
          handleSocketError(socket, 'Menu specials update failed', error);
        }
      });
    },
  
    // 3.2.4 Permission Management - Enhanced
    handlePermissions: (socket) => {
      socket.on(EVENTS.MERCHANT.UPDATE_STAFF_PERMISSIONS, async (data) => {
        try {
          await StaffPermission.update({
            staffId: data.staffId,
            permissions: data.permissions,
            restrictedAreas: data.restrictedAreas,
            approvalChain: data.approvalChain
          });
  
          // Notify staff of permission changes
          io.to(`user:${data.staffId}`).emit(EVENTS.STAFF.PERMISSIONS_UPDATED, {
            permissions: data.permissions,
            updatedBy: socket.user.id
          });
  
          // Log permission change
          await AuditLog.create({
            type: 'PERMISSION_UPDATE',
            performedBy: socket.user.id,
            affectedUser: data.staffId,
            changes: data.permissions
          });
        } catch (error) {
          handleSocketError(socket, 'Permission update failed', error);
        }
      });
    }
  };
  
  // src/handlers/staffHandlers.js
  const staffHandlers = {
    // 3.3.2 Task Management - Enhanced
    handleTaskManagement: (socket) => {
      socket.on(EVENTS.STAFF.TASK_UPDATE, async (data) => {
        try {
          const task = await Task.update({
            taskId: data.taskId,
            status: data.status,
            progress: data.progress,
            notes: data.notes,
            timeSpent: data.timeSpent
          });
  
          // Update performance metrics
          await StaffMetrics.updateTaskPerformance({
            staffId: socket.user.id,
            taskId: data.taskId,
            timeSpent: data.timeSpent,
            customerFeedback: data.customerFeedback
          });
  
          // Notify merchant of progress
          io.to(`merchant:${task.merchantId}`).emit(EVENTS.MERCHANT.TASK_PROGRESS_UPDATE, {
            taskId: task.id,
            progress: data.progress,
            metrics: await StaffMetrics.getLatestMetrics(socket.user.id)
          });
        } catch (error) {
          handleSocketError(socket, 'Task update failed', error);
        }
      });
    }
  };
  
  // src/handlers/driverHandlers.js
  const driverHandlers = {
    // 3.4.4 Navigation & Route Optimization - Enhanced
    handleNavigation: (socket) => {
      socket.on(EVENTS.DRIVER.ROUTE_UPDATE, async (data) => {
        try {
          const route = await RouteOptimizer.optimize({
            driverId: socket.user.id,
            currentLocation: data.currentLocation,
            destination: data.destination,
            trafficData: data.trafficData,
            weatherConditions: data.weatherConditions
          });
  
          // Update route and notify customer
          const activeDelivery = await Delivery.getActive(socket.user.id);
          if (activeDelivery) {
            await Delivery.updateRoute(activeDelivery.id, route);
            
            io.to(`user:${activeDelivery.customerId}`).emit(EVENTS.CUSTOMER.DELIVERY_UPDATE, {
              deliveryId: activeDelivery.id,
              newEta: route.estimatedArrival,
              currentLocation: data.currentLocation
            });
          }
        } catch (error) {
          handleSocketError(socket, 'Route optimization failed', error);
        }
      });
    }
  };
  
  // Error handling utility
  const handleSocketError = (socket, message, error) => {
    logger.error(`Socket Error: ${message}`, { error, userId: socket.user.id });
    socket.emit(EVENTS.ERROR, {
      message,
      code: error.code || 'UNKNOWN_ERROR',
      details: error.details || null
    });
  };
  
  module.exports = {
    customerHandlers,
    merchantHandlers,
    staffHandlers,
    driverHandlers,
    handleSocketError
  };

  